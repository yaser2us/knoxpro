// src/zoi/controllers/ZoiDemoController.ts
import { Controller, Get, Post, Body, Param, Query, Optional } from '@nestjs/common';
import { ZoiEntityLoaderService } from '../ZoiEntityLoaderService';
import { DataSource } from 'typeorm';
import { InjectDataSource } from '@nestjs/typeorm';

@Controller('zoi-demo')
export class ZoiDemoController {
    constructor(
        private readonly loaderService: ZoiEntityLoaderService,
        @InjectDataSource()
        private readonly dataSource: DataSource
    ) { }

    /**
     * List all generated dynamic entities
     */
    @Get('entities')
    async listEntities(): Promise<{
        message: string;
        entities: string[];
        count: number;
        endpoints: string[];
    }> {
        const entityNames = await this.loaderService.listEntityNames();
        return {
            message: 'Dynamic entities generated by ZoiEntityBuilder',
            entities: entityNames,
            count: entityNames.length,
            endpoints: entityNames.map(name => {
                // Convert entity name to JSON-API endpoint
                const kebabCase = name
                    .replace(/([A-Z])/g, '-$1')
                    .toLowerCase()
                    .replace(/^-/, '');
                return `/api/${kebabCase}s`;
            })
        };
    }

    /**
     * Get details about a specific entity
     */
    @Get('entities/:name')
    async getEntityDetails(@Param('name') name: string): Promise<any> {
        const entity = await this.loaderService.getEntityByName(name);

        if (!entity) {
            return { error: `Entity ${name} not found` };
        }

        try {
            // Get entity metadata from TypeORM
            const metadata = this.dataSource.getMetadata(entity);

            return {
                name: entity.name,
                tableName: metadata.tableName,
                columns: metadata.columns.map(col => ({
                    propertyName: col.propertyName,
                    databaseName: col.databaseName,
                    type: col.type,
                    isNullable: col.isNullable,
                    isPrimary: col.isPrimary,
                    isGenerated: col.isGenerated,
                    enum: col.enum
                })),
                relations: metadata.relations.map(rel => ({
                    propertyName: rel.propertyName,
                    type: rel.relationType,
                    target: rel.type.toString(),
                    //   isOwner: rel.isOwner,
                    joinColumns: rel.joinColumns.map(jc => jc.databaseName)
                })),
                indices: metadata.indices.map(idx => ({
                    name: idx.name,
                    columns: idx.columns.map(col => col.databaseName),
                    isUnique: idx.isUnique
                }))
            };
        } catch (error) {
            return {
                error: 'Failed to get entity metadata',
                details: error.message,
                entity_name: entity.name
            };
        }
    }

    /**
     * Debug schemas in the database
     */
    @Get('debug/schemas')
    async debugSchemas(): Promise<{ message: string }> {
        await this.loaderService.debugSchemas();
        return { message: 'Check server logs for schema debug output' };
    }

    /**
     * Get the JSON-API schema for an entity (what fields it expects)
     */
    @Get('schema/:entityName')
    async getEntitySchema(@Param('entityName') entityName: string): Promise<any> {
        try {
            const entity = await this.loaderService.getEntityByName(entityName);

            if (!entity) {
                return { error: `Entity ${entityName} not found` };
            }

            const metadata = this.dataSource.getMetadata(entity);

            // Extract required attributes
            const attributes = {};
            const relationships = {};

            metadata.columns.forEach(col => {
                if (!['id', 'createdAt', 'updatedAt'].includes(col.propertyName)) {
                    attributes[col.propertyName] = {
                        type: col.type,
                        required: !col.isNullable,
                        enum: col.enum || null
                    };
                }
            });

            metadata.relations.forEach(rel => {
                relationships[rel.propertyName] = {
                    type: rel.relationType,
                    target: rel.type.toString(),
                    required: !rel.isNullable
                };
            });

            // Generate sample JSON-API request
            const sampleRequest = {
                data: {
                    type: metadata.tableName.replace(/_/g, '-'),
                    attributes: {},
                    relationships: {}
                }
            };

            // Fill sample attributes
            Object.keys(attributes).forEach(key => {
                const attr = attributes[key];
                if (attr.enum) {
                    sampleRequest.data.attributes[key] = attr.enum[0];
                } else if (attr.type === 'varchar' || attr.type === 'text') {
                    sampleRequest.data.attributes[key] = `sample_${key}`;
                } else if (attr.type === 'int' || attr.type === 'float') {
                    sampleRequest.data.attributes[key] = 123;
                } else if (attr.type === 'boolean') {
                    sampleRequest.data.attributes[key] = true;
                } else if (attr.type === 'date') {
                    sampleRequest.data.attributes[key] = '2025-01-15';
                } else if (attr.type === 'uuid') {
                    sampleRequest.data.attributes[key] = '550e8400-e29b-41d4-a716-446655440000';
                } else {
                    sampleRequest.data.attributes[key] = `sample_${key}`;
                }
            });

            // Fill sample relationships
            Object.keys(relationships).forEach(key => {
                const rel = relationships[key];
                const targetType = rel.target.toLowerCase().replace(/([A-Z])/g, '-$1').replace(/^-/, '');
                sampleRequest.data.relationships[key] = {
                    data: {
                        type: targetType,
                        id: '550e8400-e29b-41d4-a716-446655440000'
                    }
                };
            });

            return {
                entity_name: entityName,
                table_name: metadata.tableName,
                json_api_type: metadata.tableName.replace(/_/g, '-'),
                attributes,
                relationships,
                sample_request: sampleRequest,
                endpoints: {
                    create: `POST /api/${metadata.tableName.replace(/_/g, '-')}`,
                    list: `GET /api/${metadata.tableName.replace(/_/g, '-')}`,
                    get: `GET /api/${metadata.tableName.replace(/_/g, '-')}/{id}`,
                    update: `PATCH /api/${metadata.tableName.replace(/_/g, '-')}/{id}`,
                    delete: `DELETE /api/${metadata.tableName.replace(/_/g, '-')}/{id}`
                }
            };

        } catch (error) {
            return {
                error: 'Failed to get entity schema',
                details: error.message
            };
        }
    }
    //   @Get('schema/:entityName')
    //   async getEntitySchema(@Param('entityName') entityName: string): Promise<any> {
    //     try {
    //       const entity = await this.loaderService.getEntityByName(entityName);

    //       if (!entity) {
    //         return { error: `Entity ${entityName} not found` };
    //       }

    //       const metadata = this.dataSource.getMetadata(entity);

    //       // Extract required attributes
    //       const attributes = {};
    //       const relationships = {};

    //       metadata.columns.forEach(col => {
    //         if (!['id', 'createdAt', 'updatedAt'].includes(col.propertyName)) {
    //           attributes[col.propertyName] = {
    //             type: col.type,
    //             required: !col.isNullable,
    //             enum: col.enum || null
    //           };
    //         }
    //       });

    //       metadata.relations.forEach(rel => {
    //         relationships[rel.propertyName] = {
    //           type: rel.relationType,
    //           target: rel.type.toString(),
    //           required: !rel.isNullable
    //         };
    //       });

    //       // Generate sample JSON-API request
    //       const sampleRequest = {
    //         data: {
    //           type: metadata.tableName.replace(/_/g, '-'),
    //           attributes: {},
    //           relationships: {}
    //         }
    //       };

    //       // Fill sample attributes
    //       Object.keys(attributes).forEach(key => {
    //         const attr = attributes[key];
    //         if (attr.enum) {
    //           sampleRequest.data.attributes[key] = attr.enum[0];
    //         } else if (attr.type === 'varchar' || attr.type === 'text') {
    //           sampleRequest.data.attributes[key] = `sample_${key}`;
    //         } else if (attr.type === 'int' || attr.type === 'float') {
    //           sampleRequest.data.attributes[key] = 123;
    //         } else if (attr.type === 'boolean') {
    //           sampleRequest.data.attributes[key] = true;
    //         } else if (attr.type === 'date') {
    //           sampleRequest.data.attributes[key] = '2025-01-15';
    //         } else if (attr.type === 'uuid') {
    //           sampleRequest.data.attributes[key] = '550e8400-e29b-41d4-a716-446655440000';
    //         } else {
    //           sampleRequest.data.attributes[key] = `sample_${key}`;
    //         }
    //       });

    //       // Fill sample relationships
    //       Object.keys(relationships).forEach(key => {
    //         const rel = relationships[key];
    //         const targetType = rel.target.toLowerCase().replace(/([A-Z])/g, '-$1').replace(/^-/, '');
    //         sampleRequest.data.relationships[key] = {
    //           data: {
    //             type: targetType,
    //             id: '550e8400-e29b-41d4-a716-446655440000'
    //           }
    //         };
    //       });

    //       return {
    //         entity_name: entityName,
    //         table_name: metadata.tableName,
    //         json_api_type: metadata.tableName.replace(/_/g, '-'),
    //         attributes,
    //         relationships,
    //         sample_request: sampleRequest,
    //         endpoints: {
    //           create: `POST /api/${metadata.tableName.replace(/_/g, '-')}`,
    //           list: `GET /api/${metadata.tableName.replace(/_/g, '-')}`,
    //           get: `GET /api/${metadata.tableName.replace(/_/g, '-')}/{id}`,
    //           update: `PATCH /api/${metadata.tableName.replace(/_/g, '-')}/{id}`,
    //           delete: `DELETE /api/${metadata.tableName.replace(/_/g, '-')}/{id}`
    //         }
    //       };

    //     } catch (error) {
    //       return {
    //         error: 'Failed to get entity schema',
    //         details: error.message
    //       };
    //     }
    //   }

    /**
     * Test creating a blood test (if the schema is loaded)
     */
    @Post('test/blood-test')
    async createTestBloodTest(@Body() data: any): Promise<any> {
        try {
            const bloodTestEntity = await this.loaderService.getEntityByName('BloodTest');

            if (!bloodTestEntity) {
                return {
                    error: 'BloodTest entity not found. Make sure to add the BloodTestTemplate to document_templates.',
                    hint: 'Run the SQL from the test schema artifact first.'
                };
            }

            const repository = this.dataSource.getRepository(bloodTestEntity);

            const bloodTest = repository.create({
                patient_name: data.patient_name || 'Test Patient',
                patient_id: data.patient_id || 'P123456',
                test_type: data.test_type || 'CBC',
                sample_date: data.sample_date || new Date().toISOString().split('T')[0],
                sample_type: data.sample_type || 'Blood',
                notes: data.notes || 'Created via demo controller',
                workflow_status: 'confirmation',
                created_by_id: data.created_by_id,
                workspace_id: data.workspace_id
            });

            const savedBloodTest = await repository.save(bloodTest);

            return {
                message: 'Blood test created successfully',
                id: savedBloodTest.id,
                data: savedBloodTest,
                next_steps: [
                    'Add signatures via POST /zoi-demo/test/signature',
                    `Check JSON-API endpoint: GET /api/blood-tests/${savedBloodTest.id}`,
                    'Query with relationships: GET /api/blood-tests?include=signatures'
                ]
            };

        } catch (error) {
            return {
                error: 'Failed to create blood test',
                details: error.message,
                stack: error.stack
            };
        }
    }

    /**
     * Test adding a signature (basic version without workflow service)
     */
    @Post('test/signature')
    async addTestSignature(@Body() data: {
        blood_test_id: string;
        user_id: string;
        signature_step?: string;
        signature_role?: string;
        notes?: string;
    }): Promise<any> {
        try {
            const signatureEntity = await this.loaderService.getEntityByName('BloodTestSignature');

            if (!signatureEntity) {
                return {
                    error: 'BloodTestSignature entity not found',
                    hint: 'Make sure the BloodTest schema includes a workflow configuration'
                };
            }

            const repository = this.dataSource.getRepository(signatureEntity);

            const signature = repository.create({
                blood_test_id: data.blood_test_id,
                user_id: data.user_id,
                signature_step: data.signature_step || 'confirmation',
                signature_role: data.signature_role || 'confirmer',
                signature_data: 'Demo Signature',
                signed_at: new Date(),
                notes: data.notes || 'Added via demo controller'
            });

            const savedSignature = await repository.save(signature);

            return {
                message: 'Signature added successfully',
                signature: savedSignature,
                next_steps: [
                    'View via JSON-API: GET /api/blood-test-signatures?include=user,blood_test',
                    'Check blood test: GET /api/blood-tests/' + data.blood_test_id + '?include=signatures'
                ]
            };

        } catch (error) {
            return {
                error: 'Failed to add signature',
                details: error.message
            };
        }
    }

    /**
     * Get basic workflow status (without workflow service)
     */
    @Get('workflow/:entityType/:entityId')
    async getWorkflowStatus(
        @Param('entityType') entityType: string,
        @Param('entityId') entityId: string
    ): Promise<any> {
        try {
            const signatureEntityName = `${entityType}Signature`;
            const signatureEntity = await this.loaderService.getEntityByName(signatureEntityName);

            if (!signatureEntity) {
                return {
                    error: `No signature entity found for ${entityType}`,
                    entity_type: entityType,
                    entity_id: entityId
                };
            }

            const signatureRepo = this.dataSource.getRepository(signatureEntity);

            // Count signatures by step
            const signatures = await signatureRepo.find({
                where: {
                    [`${entityType.toLowerCase()}_id`]: entityId
                }
            });

            const signaturesByStep = signatures.reduce((acc, sig) => {
                const step = sig.signature_step || 'unknown';
                acc[step] = (acc[step] || 0) + 1;
                return acc;
            }, {} as Record<string, number>);

            return {
                entity_type: entityType,
                entity_id: entityId,
                total_signatures: signatures.length,
                signatures_by_step: signaturesByStep,
                signed_signatures: signatures.filter(s => s.signed_at).length,
                pending_signatures: signatures.filter(s => !s.signed_at).length
            };

        } catch (error) {
            return {
                error: 'Failed to get workflow status',
                details: error.message
            };
        }
    }

    /**
     * Health check for the dynamic system
     */
    @Get('health')
    async healthCheck(): Promise<any> {
        try {
            const entityNames = await this.loaderService.listEntityNames();

            return {
                status: 'healthy',
                timestamp: new Date().toISOString(),
                dynamic_entities_loaded: entityNames.length,
                entities: entityNames,
                workflow_entities: entityNames.filter(name =>
                    name.includes('Signature') ||
                    name.includes('Approval') ||
                    name.includes('Log')
                ),
                endpoints_available: [
                    'GET /zoi-demo/entities - List all dynamic entities',
                    'GET /zoi-demo/entities/:name - Get entity details',
                    'POST /zoi-demo/test/blood-test - Create test blood test',
                    'POST /zoi-demo/test/signature - Add test signature',
                    'GET /zoi-demo/workflow/:type/:id - Get basic workflow status'
                ]
            };

        } catch (error) {
            return {
                status: 'error',
                error: error.message,
                timestamp: new Date().toISOString()
            };
        }
    }

    @Get('debug/entities')
    async debugEntities() {
        return await this.loaderService.debugSchemas();
    }

    @Get('debug/check/:entityName')
    async checkEntity(@Param('entityName') entityName: string) {
        const exists = await this.loaderService.hasEntity(entityName);
        const entity = await this.loaderService.getEntityByName(entityName);
        return { exists, found: !!entity };
    }
}